/* $Id: Grammar.c,v 1.1 1999/02/08 16:30:38 phelps Exp $ */

#include <stdio.h>
#include <stdlib.h>
#include "Grammar.h"
#include "Production.h"

struct Grammar_t
{
    /* The number of productions */
    int count;

    /* The number of non-terminals in the grammar */
    int nonterminal_count;

    /* The number of terminals in the grammar */
    int terminal_count;

    /* The Grammar's productions */
    Production *productions;

    /* An array which maps Nonterminal indices to a List of Productions */
    List *productionsByNonterminal;

    /* This table records which productions are spontaneously
     * generated by a given nonterminal.  If generates[3][4] is
     * non-zero, then there is a production of the form
     * <nonterminal-3> ::= <nonterminal-4> ... in the grammar */
    char **generates;
};


/*
 *
 * Static functions
 *
 */

/* Copies the contents of the productions list into the receiver's productions */
void PopulateProductions(Production production, Grammar self, int *index)
{
    int i = Production_getNonterminalIndex(production);
    self -> productions[(*index)++] = production;

    if (self -> productionsByNonterminal[i] == NULL)
    {
	self -> productionsByNonterminal[i] = List_alloc();
	self -> generates[i] = (char *)calloc(self -> nonterminal_count, sizeof(char));
    }

    List_addLast(self -> productionsByNonterminal[i], production);
}


/*
 *
 * Exported functions
 *
 */

/* Allocates a new Grammar with the given Productions */
Grammar Grammar_alloc(List productions, int nonterminal_count, int terminal_count)
{
    Grammar self;
    int index = 0;

    /* Allocate space for a new Grammar */
    if ((self = (Grammar) malloc(sizeof(struct Grammar_t))) == NULL)
    {
	fprintf(stderr, "*** Out of memory!\n");
	exit(1);
    }

    /* Set some initial values */
    self -> count = List_size(productions);
    self -> nonterminal_count = nonterminal_count;
    self -> terminal_count = terminal_count;

    /* Copy the productions into the receiver */
    self -> productions = (Production *)calloc(self -> count, sizeof(Production));
    self -> productionsByNonterminal = (List *)calloc(nonterminal_count, sizeof(List));
    self -> generates = (char **)calloc(nonterminal_count, sizeof(char *));
    List_doWithWith(productions, PopulateProductions, self, &index);

    return self;
}

/* Frees the resources consumed by the receiver */
void Grammar_free(Grammar self)
{
    int index;

    for (index = 0; index < self -> count; index++)
    {
	Production_free(self -> productions[index]);
    }

    free(self);
}

/* Pretty-prints the receiver */
void Grammar_debug(Grammar self, FILE *out)
{
    int index;

    fprintf(out, "Grammar %p\n", self);
    for (index = 0; index < self -> nonterminal_count; index++)
    {
	fprintf(out, "  %d ", index);
	List_doWith(self -> productionsByNonterminal[index], Production_print, out);
	fprintf(out, "\n");
    }
}
