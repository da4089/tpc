/* $Id: Grammar.c,v 1.3 1999/02/08 18:28:30 phelps Exp $ */

#include <stdio.h>
#include <stdlib.h>
#include "Grammar.h"
#include "Production.h"

struct Grammar_t
{
    /* The number of productions */
    int production_count;

    /* The number of non-terminals in the grammar */
    int nonterminal_count;

    /* The number of terminals in the grammar */
    int terminal_count;

    /* The Grammar's productions */
    Production *productions;

    /* An array which maps Nonterminal indices to a List of Productions */
    List *productionsByNonterminal;

    /* This table records which productions are spontaneously
     * generated by a given nonterminal.  If generates[3][4] is
     * non-zero, then there is a production of the form
     * <nonterminal-3> ::= <nonterminal-4> ... in the grammar */
    char **generates;
};


/*
 *
 * Static functions
 *
 */

/* Mark the box that indicates that non-terminal x generates non-terminal x */
static void MarkGenerates(Grammar self, int x, int y)
{
    int i;

    /* If the box is already marked then we've no further work to do */
    if (self -> generates[x][y])
    {
	return;
    }

    /* Mark the box */
    self -> generates[x][y] = 1;

    /* Propagate the mark to any non-terminal which generates us */
    for (i = 0; i < self -> nonterminal_count; i++)
    {
	if ((self -> generates[i] != NULL) && (self -> generates[i][x] != 0))
	{
	    MarkGenerates(self, i, y);
	}
    }

    /* Propagate the marks of the non-terminal we just generated */
    if (self -> generates[y] != NULL)
    {
	for (i = 0; i < self -> nonterminal_count; i++)
	{
	    if (self -> generates[y][i] != 0)
	    {
		MarkGenerates(self, x, i);
	    }
	}
    }
}

/* Copies the contents of the productions list into the receiver's productions */
static void PopulateProductions(Production production, Grammar self, int *index)
{
    Component component = Production_getFirstComponent(production);
    int i = Production_getNonterminalIndex(production);
    self -> productions[(*index)++] = production;

    /* If this is the first time we've encountered this non-terminal,
     * then update our tables */
    if (self -> productionsByNonterminal[i] == NULL)
    {
	self -> productionsByNonterminal[i] = List_alloc();
	self -> generates[i] = (char *)calloc(self -> nonterminal_count, sizeof(char));
    }

    /* Append the production to the end of the list for the non-terminal */
    List_addLast(self -> productionsByNonterminal[i], production);

    /* Record a mark in the "generates" table for this non-terminal
     * and first Component of the production if that component is a
     * Nonterminal */
    if (Component_isNonterminal(component))
    {
	int j = Nonterminal_getIndex((Nonterminal)component);
	MarkGenerates(self, i, j);
    }
}


/*
 *
 * Exported functions
 *
 */

/* Allocates a new Grammar with the given Productions */
Grammar Grammar_alloc(List productions, int nonterminal_count, int terminal_count)
{
    Grammar self;
    int index = 0;

    /* Allocate space for a new Grammar */
    if ((self = (Grammar) malloc(sizeof(struct Grammar_t))) == NULL)
    {
	fprintf(stderr, "*** Out of memory!\n");
	exit(1);
    }

    /* Set some initial values */
    self -> production_count = List_size(productions);
    self -> nonterminal_count = nonterminal_count;
    self -> terminal_count = terminal_count;

    /* Copy the productions into the receiver */
    self -> productions = (Production *)calloc(self -> production_count, sizeof(Production));
    self -> productionsByNonterminal = (List *)calloc(nonterminal_count, sizeof(List));
    self -> generates = (char **)calloc(nonterminal_count, sizeof(char *));
    List_doWithWith(productions, PopulateProductions, self, &index);

    return self;
}

/* Frees the resources consumed by the receiver */
void Grammar_free(Grammar self)
{
    int index;

    for (index = 0; index < self -> production_count; index++)
    {
	Production_free(self -> productions[index]);
    }

    free(self);
}

/* Pretty-prints the receiver */
void Grammar_debug(Grammar self, FILE *out)
{
    int index;

    fprintf(out, "Grammar %p\n", self);
    for (index = 0; index < self -> nonterminal_count; index++)
    {
	fprintf(out, "  %d ", index);
	List_doWith(self -> productionsByNonterminal[index], Production_print, out);
	fprintf(out, "\n");
    }
}


/* Encodes a Production and offset in a single integer */
int Grammar_encode(Grammar self, Production production, int offset)
{
    return (self -> production_count * offset) + Production_getIndex(production);
}

/* Answers the Production and offset encoded in the integer */
int Grammar_decode(Grammar self, int number, Production *production_return)
{
    *production_return = self -> productions[number % self -> production_count];
    return number / self -> production_count;
}
