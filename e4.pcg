################################################################
#
#  Copyright (C) DSTC Pty Ltd (ACN 052 372 577) 1998.
#  Unpublished work.  All Rights Reserved.
#
#  The software contained on this media is the property of the
#  DSTC Pty Ltd.  Use of this software is strictly in accordance
#  with the license agreement in the accompanying LICENSE.DOC
#  file.  If your distribution of this software does not contain
#  a LICENSE.DOC file then you have no rights to use this
#  software in any manner and should contact DSTC at the address
#  below to determine an appropriate licensing arrangement.
#
#     DSTC Pty Ltd
#     Level 7, Gehrmann Labs
#     University of Queensland
#     St Lucia, 4072
#     Australia
#     Tel: +61 7 3365 4310
#     Fax: +61 7 3365 4311
#     Email: enquiries@dstc.edu.au
#
#  This software is being provided "AS IS" without warranty of
#  any kind.  In no event shall DSTC Pty Ltd be liable for
#  damage of any kind arising out of or in connection with
#  the use or performance of this software.
#
#
#  Project:  Elvin: event notification
#
#  File:     $Source: /home/phelps/CVS/tpc/e4.pcg,v $
#
#  Description:
#            Routine for converting process to a daemon
#
#  Author:
#            Ted Phelps
#
#################################################################

<sub-exp> ::= <disjunction>
	[Accept]

#
# We introduce <function-exp> in order to get around the inherent
# ambiguity of the grammar.  Without these two productions, there is
# no way to reduce the following two sentences:
#
#	(exists(FOO))
#	(sizeof(BOB)) == 3
#
# By adding these two productions, the decision about whether these
# the function returns a boolean value or a number/string is delayed
# until we have enough information to do the proper reduction
#
# Note that the first function-exp production must appear *before* the 
# <bool-exp> ::= <function-exp> or <num-value> ::= <function-exp>
# productions because the parser compiler will use the first listed
# production when it encounters this ambiguity.
#

<function-exp> ::= LPAREN <function-exp> RPAREN
	[CreateNestedFunctionExp]
<function-exp> ::= <function>
	[FunctionExpFromFunction]

<function> ::= ID LPAREN <arg-list> RPAREN
	[CreateFunction]

<arg-list> ::= <arg-list> COMMA <value>
	[ExtendArgList]
<arg-list> ::= <value>
	[CreateArgList]


#
# Boolean expression productions
#

<disjunction> ::= <disjunction> OR <xor-exp>
	[ExtendDisjunction]
<disjunction> ::= <xor-exp>
	[DisjunctionFromXorExp]

<xor-exp> ::= <xor-exp> XOR <conjunction>
	[ExtendXorExp]
<xor-exp> ::= <conjunction>
	[XorExpFromConjunction]

<conjunction> ::= <conjunction> AND <bool-exp>
	[ExtendConjunction]
<conjunction> ::= <bool-exp>
	[ConjunctionFromBoolExp]

<bool-exp> ::= <value> <predicate> <value>
	[BoolExpFromComparison]
<bool-exp> ::= <function-exp>
	[BoolExpFromFunctionExp]
<bool-exp> ::= BANG <bool-exp>
	[BoolExpFromNegation]
<bool-exp> ::= LPAREN <disjunction> RPAREN
	[CreateNestedBoolExp]


<value> ::= STRING
	[ValueFromString]
<value> ::= <bit-disjunction>
	[ValueFromBitDisjunction]


#
# Comparison predicates
#

<predicate> ::= EQ
	[PredicateFromEQ]
<predicate> ::= NEQ
	[PredicateFromNEQ]
<predicate> ::= LT
	[PredicateFromLT]
<predicate> ::= GT
	[PredicateFromGT]
<predicate> ::= LE
	[PredicateFromLE]
<predicate> ::= GE
	[PredicateFromGE]


#
# String and numeric expression productions
#

<bit-disjunction> ::= <bit-disjunction> BIT_OR <bit-xor-exp>
	[ExtendBitDisjunction]
<bit-disjunction> ::= <bit-xor-exp>
	[BitDisjunctionFromBitXorExp]

<bit-xor-exp> ::= <bit-xor-exp> BIT_XOR <bit-conjunction>
	[ExtendBitXorExp]
<bit-xor-exp> ::= <bit-conjunction>
	[BitXorExpFromBitConjunction]

<bit-conjunction> ::= <bit-conjunction> BIT_AND <bit-shift-exp>
	[ExtendBitConjunction]
<bit-conjunction> ::= <bit-shift-exp>
	[BitConjunctionFromBitShiftExp]

<bit-shift-exp> ::= <bit-shift-exp> BIT_SHL <sum>
	[ExtendBitSHL]
<bit-shift-exp> ::= <bit-shift-exp> BIT_SHR <sum>
	[ExtendBitSHR]
<bit-shift-exp> ::= <bit-shift-exp> BIT_LSR <sum>
	[ExtendBitLSR]
<bit-shift-exp> ::= <sum>
	[BitShiftExpFromSum]

<sum> ::= <sum> PLUS <product>
	[SumFromPlusExp]
<sum> ::= <sum> MINUS <product>
	[SumFromMinusExp]
<sum> ::= <product>
	[SumFromProduct]

<product> ::= <product> TIMES <num-exp>
	[ProductFromTimesExp]
<product> ::= <product> DIV <num-exp>
	[ProductFromDivExp]
<product> ::= <product> MOD <num-exp>
	[ProductFromModExp]
<product> ::= <num-exp>
	[ProductFromNumExp]

<num-exp> ::= MINUS <num-value>
	[Function]
<num-exp> ::= NEG <num-value>
	[Function]
<num-exp> ::= <num-value>
	[NumExpFromNumValue]


<num-value> ::= INT32
	[NumValueFromINT32]
<num-value> ::= INT64
	[Function]
<num-value> ::= REAL64
	[Function]
<num-value> ::= <name>
	[NumValueFromName]
<num-value> ::= <function-exp>
	[Function]
<num-value> ::= LPAREN <value> RPAREN
	[CreateNestedNumValue]

<name> ::= ID
	[NameFromId]


