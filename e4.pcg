# $Id: e4.pcg,v 1.9 1999/02/19 10:32:13 phelps Exp $
#
# Copyright goes here
#
# Author: Ted Phelps

<sub-exp> ::= <disjunction>
	[Accept]

#
# We introduce <function-exp> in order to get around the inherent
# ambiguity of the grammar.  Without these two productions, there is
# no way to reduce the following two sentences:
#
#	(exists(FOO))
#	(sizeof(BOB)) == 3
#
# By adding these two productions, the decision about whether these
# the function returns a boolean value or a number/string is delayed
# until we have enough information to do the proper reduction
#
# Note that the first function-exp production must appear *before* the 
# <bool-exp> ::= <function-exp> or <num-value> ::= <function-exp>
# productions because the parser compiler will use the first listed
# production when it encounters this ambiguity.
#

<function-exp> ::= LPAREN <function-exp> RPAREN
	[CreateNestedFunctionExp]
<function-exp> ::= <function>
	[FunctionExpFromFunction]

<function> ::= ID LPAREN <arg-list> RPAREN
	[CreateFunction]

<arg-list> ::= <arg-list> COMMA <value>
	[Function]
<arg-list> ::= <value>
	[CreateArgList]


#
# Boolean expression productions
#

<disjunction> ::= <disjunction> OR <xor-exp>
	[ExtendDisjunction]
<disjunction> ::= <xor-exp>
	[DisjunctionFromXorExp]

<xor-exp> ::= <xor-exp> XOR <conjunction>
	[ExtendXorExp]
<xor-exp> ::= <conjunction>
	[XorExpFromConjunction]

<conjunction> ::= <conjunction> AND <bool-exp>
	[ExtendConjunction]
<conjunction> ::= <bool-exp>
	[ConjunctionFromBoolExp]

<bool-exp> ::= <value> <predicate> <value>
	[BoolExpFromComparison]
<bool-exp> ::= <function-exp>
	[BoolExpFromFunctionExp]
<bool-exp> ::= BANG <bool-exp>
	[BoolExpFromNegation]
<bool-exp> ::= LPAREN <disjunction> RPAREN
	[CreateNestedBoolExp]


<value> ::= STRING
	[ValueFromString]
<value> ::= <bit-disjunction>
	[ValueFromBitDisjunction]


#
# Comparison predicates
#

<predicate> ::= EQ
	[PredicateFromEQ]
<predicate> ::= NEQ
	[Function]
<predicate> ::= LT
	[Function]
<predicate> ::= GT
	[Function]
<predicate> ::= LE
	[PredicateFromLE]
<predicate> ::= GE
	[Function]


#
# String and numeric expression productions
#

<bit-disjunction> ::= <bit-disjunction> BIT_OR <bit-xor-exp>
	[Function]
<bit-disjunction> ::= <bit-xor-exp>
	[BitDisjunctionFromBitXorExp]

<bit-xor-exp> ::= <bit-xor-exp> BIT_XOR <bit-conjunction>
	[Function]
<bit-xor-exp> ::= <bit-conjunction>
	[BitXorExpFromBitConjunction]

<bit-conjunction> ::= <bit-conjunction> BIT_AND <bit-shift-exp>
	[Function]
<bit-conjunction> ::= <bit-shift-exp>
	[BitConjunctionFromBitShiftExp]

<bit-shift-exp> ::= <bit-shift-exp> BIT_SHL <sum>
	[Function]
<bit-shift-exp> ::= <bit-shift-exp> BIT_SHR <sum>
	[Function]
<bit-shift-exp> ::= <bit-shift-exp> BIT_LSR <sum>
	[Function]
<bit-shift-exp> ::= <sum>
	[BitShiftExpFromSum]

<sum> ::= <sum> PLUS <product>
	[SumFromPlusExp]
<sum> ::= <sum> MINUS <product>
	[SumFromMinusExp]
<sum> ::= <product>
	[SumFromProduct]

<product> ::= <product> TIMES <num-exp>
	[ProductFromTimesExp]
<product> ::= <product> DIV <num-exp>
	[Function]
<product> ::= <product> MOD <num-exp>
	[ProductFromModExp]
<product> ::= <num-exp>
	[ProductFromNumExp]

<num-exp> ::= MINUS <num-value>
	[Function]
<num-exp> ::= NEG <num-value>
	[Function]
<num-exp> ::= <num-value>
	[NumExpFromNumValue]


<num-value> ::= INT32
	[NumValueFromINT32]
<num-value> ::= INT64
	[Function]
<num-value> ::= REAL64
	[Function]
<num-value> ::= <name>
	[NumValueFromName]
<num-value> ::= <function-exp>
	[NumValueFromFunctionExp]
<num-value> ::= LPAREN <value> RPAREN
	[CreateNestedNumValue]


# The following productions let us use just about anything as an
# attribute name.  Thus expressions such as the following are
# completely valid, if somewhat confusing:
#
#	== != && || ^^ <= >
#
# The same expression, except with the attribute names wrapped in
# square brackets would read as follows:
#
#	[==] != [&&] || [^^] <= [>]
#
# We're not saying it's a good idea to use "==" as an attribute name,
# but we're not going to stop you either.

<name> ::= ID
	[NameFromId]
<name> ::= EQ
	[Function]
<name> ::= NEQ
	[Function]
<name> ::= LT
	[Function]
<name> ::= GT
	[Function]
<name> ::= GE
	[Function]
<name> ::= LE
	[Function]
<name> ::= OR
	[Function]
<name> ::= XOR
	[Function]
<name> ::= AND
	[Function]
<name> ::= BIT_OR
	[Function]
<name> ::= BIT_XOR
	[Function]
<name> ::= BIT_AND
	[Function]
<name> ::= BIT_SHL
	[Function]
<name> ::= BIT_SHR
	[Function]
<name> ::= BIT_LSR
	[Function]
<name> ::= PLUS
	[Function]
<name> ::= MOD
	[Function]
<name> ::= TIMES
	[Function]
<name> ::= DIV
	[Function]


